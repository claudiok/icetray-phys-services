/**
 @page phys-services-phys-source Using the Origin Classes 

 @author <a href="http://icecube.umd.edu/pretz">John Pretz</a>

 @section phys-services-phys-source-intro Introduction

 The idea here is that the code for most source modules is all redundant
 and not particularly simple.  When a person wants to implement some new
 way of reading the data, they are supposed to implement an I3Module or
 and I3Source 
 which looks at the data stream and decides when to add their data.
 They have to look on all streams so they know when an update is necessary, 
 and this approach introduces a lot of coupling between the pieces that
 are supposed to be putting data into the system.

 The idea is that the I3UberSource module has four interfaces available
 to it for getting the Geometry, the Calibration, the detector status
 and some Events.  Those
 interfaces are the I3EventOrigin, I3GeometryOrigin., and 
 I3CalibrationOrigin and the I3DetectorStatusOrigin.  
 These four are abstract interfaces which allow
 the I3UberSource to decide in which order Frames should be issued 
 and what data they should contain.

 The idea is that when it comes time for a frame, the I3UberSource
 looks at each of these three interfaces and gets the next Time for each.
 If a geometry stop is next, then it gets an I3Geometry and I3GeometryHeader
 from the interfaces and puts these in a frame.  Same for the I3Event and 
 I3Calibration.  

 The idea is to make it easy to extend different ways of getting frames.
 For a particular example, there would be one implementation of the 
 I3GeometryOrigin which gets one geometry for a file and gives it up.
 There would be another implementation which reads from the database.  One 
 also for reading from an f2k file. 

 Same for calibration.

 Since the interfaces are independent it should be easy to swap them out 
 and mix-and-match them.  For instance get the events from an f2k file
 and the calibration from a database and the geometry from a .geo file.

 Some people are not comfortable with the idea of one module doing all
 the work, so there is another way to use these classes.  There are four
 modules which each use a different service, rather than one module
 using all four.  The four modules I3PhysicsSource, I3DetectorStatusSource,
 I3GeometrySource and I3CalibrationSource can be added rather than the 
 one I3UberSource module.

 I'm hoping that this becomes the cannonical way of getting data into the 
 system but there are competing paradigms.  Whatever works.
 
 Remember that to be able to use these, you've got to add implementations of
 the four 'Origin' services.  Here are two working scripts to get you started.
 It's included in the release.  To run it just do
 @code
 % root phys-services/resources/scripts/UberSourceExample.C
 % root phys-services/resources/scripts/FourSourcesExample.C
 @endcode

 Here's UberSourceExample.C in case you don't want to look it up:

 @include UberSourceExample.C

 And FourSourcesExample.C in case you don't want to look it up.

 @include FourSourcesExample.C

*/
